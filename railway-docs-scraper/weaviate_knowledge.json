{
  "railway_deployment": [
    {
      "content": "WorkspacesWorkspaces are how organizations are represented within Railway. A default workspaces is made with your account, and new ones can be created via the Pro or Enterprise plans. For more information, visit our documentation on pricing or railway.com/pricing. Note: Effective March 3rd, 2025, for users on Railway hosted metal instances, all seat costs will be waived. Creating a Workspace Organizations can create a workspace by heading to the Create Workspace page and entering the required information. Managing Workspaces You can open your workspace's settings page to manage members and see billing information by clicking the gear icon next to the name of your workspace on the dashboard. Inviting Members Under the People tab of the settings page, you can invite members. There are three roles for Workspace members: Admin: Full administration of the Workspace and all Workspace projects Member: Access to all Workspace projects Deployer: View projects and deploy through commits to repos via GitHub integration. AdminMemberDeployerAutomatic GitHub deployments\u2714\ufe0f\u2714\ufe0f\u2714\ufe0fCLI deployments\u2714\ufe0f\u2714\ufe0f\u274cCreating variables\u2714\ufe0f\u2714\ufe0f\u274cModifying variables\u2714\ufe0f\u2714\ufe0f\u274cDeleting variables\u2714\ufe0f\u2714\ufe0f\u274cModifying service settings\u2714\ufe0f\u274c\u274cCreating services\u2714\ufe0f\u2714\ufe0f\u274cDeleting services\u2714\ufe0f\u274c\u274cViewing logs\u2714\ufe0f\u2714\ufe0f\u274cCreating volumes\u2714\ufe0f\u2714\ufe0f\u274cDeleting volumes\u2714\ufe0f\u274c\u274cCreating new projects\u2714\ufe0f\u2714\ufe0f\u274cDeleting projects\u2714\ufe0f\u274c\u274cAdding additional members\u2714\ufe0f\u274c\u274cRemoving members\u2714\ufe0f\u274c\u274cChanging member roles\u2714\ufe0f\u274c\u274cAdding trusted domains\u2714\ufe0f\u274c\u274cMaking a withdrawal\u2714\ufe0f\u274c\u274cAccessing billing settings\u2714\ufe0f\u274c\u274c Note: Changes that trigger a deployment will skip the approval requirement when the author has a Deployer role (or higher) and their GitHub account is connected. Trusted Domains Trusted domains may be configured on the workspace settings page. Note that workspace members added via trusted domain will be billed at the normal rate. You can automate the onboarding of new workspace members with trusted domains. Railway users that sign up with one of the trusted domains associated with your workspace will automatically be granted access to the workspace with the specified role (see above). For example, new users with example.com email addresses will automatically be added to your workspaces that have the example.com trusted domain. We verify that you have administrative access to the domain by looking for services in your workspace that use this domain or a subdomain. Make sure to setup a custom domain on your service before adding it as a trusted domain. Transferring Projects Transfer projects from another Workspace or Hobby workspace easily. Detailed instructions can be found here. Invoicing and Billing Railway offers a consumption-based pricing model for your projects. You don't get charged for resources you don't use, instead, Railway charges by the minute for each vCPU and memory resource your service uses. However, if you expect to use a consistent amount of resources for large companies, you can contact us for a quote and demo. Railway will work with you to find a solution that works for your needs. We are willing to offer Purchase Orders and concierge onboarding for large companies. Committed Spend Tiers Railway offers committed spend tiers for customers with consistent usage needs. Instead of negotiated contract pricing, customers can commit to a specific monthly threshold to unlock additional features and services. Monthly thresholds for addons is found in our commited spend pricing. Reach out to us at [email\u00a0protected] for more information. FAQs How do I get my Pro seat costs waived? As of March 3rd, 2025, Railway waives all seat costs for users on Railway hosted metal instances. To qualify for this benefit: Your workspace must be on the Pro plan Your services must be quality for metal pricing and run on Railway hosted metal instances This waiver will be automatically applied for your next monthly invoice If you're interested in moving to Railway hosted metal instances to take advantage of this benefit, please contact our team to discuss your requirements and set up a dedicated host solution. The seat cost waiver provides significant savings for workspaces of all sizes, especially as your workspace grows. This is part of our commitment to providing more flexible and cost-effective pricing options for our customers.Prev SupportNext Usage LimitsEdit this file on GitHub",
      "title": "Workspaces | Railway Docs",
      "url": "https://docs.railway.com/reference/teams"
    },
    {
      "content": "Controlling GitHub AutodeploysServices that are linked to a GitHub repo automatically deploy when new commits are detected in the connected branch. Configure the GitHub Branch for Deployment Triggers To update the branch that triggers automatic deployments, go to your Service Settings and choose the appropriate trigger branch. Disable Automatic Deployments To disable automatic deployment, simply hit Disconnect in the Service Settings menu. Note: To manually trigger a deployment from the latest commit, use the Command Pallette: CMD + K -> \"Deploy Latest Commit\". This will deploy the latest commit from the Default branch in GitHub. Currently, there is no way to force a deploy from a branch other than the Default without connecting it in your service settings. Wait for CI Please make sure you have accepted our updated GitHub permissions required for this feature to work. To ensure Railway waits for your GitHub Actions to run successfully before triggering a new deployment, you should enable Wait for CI. Requirements You must have a GitHub workflow defined in your repository. The GitHub workflow must contain a directive to run on push: on: push: branches: - main Enabling Wait for CI If your workflow satisfies the requirements above, you will see the Wait for CI flag in service settings. Toggle this on to ensure Railway waits for your GitHub Actions to run successfully before triggering a new deployment. When enabled, deployments will be moved to a WAITING state while your workflows are running. If any workflow fails, the deployments will be SKIPPED. When all workflows are successful, deployments will proceed as usual.Prev Deployment ActionsNext Optimize PerformanceEdit this file on GitHub",
      "title": "Controlling GitHub Autodeploys | Railway Docs",
      "url": "https://docs.railway.com/guides/github-autodeploys"
    },
    {
      "content": "Deployment ActionsVarious actions can be taken on Deployments from within the Service -> Deployments tab and clicking on the three dots at the end of a previous deployment. Rollback Rollback to previous deployments if mistakes were made. To perform a rollback, click the three dots at the end of a previous deployment, you will then be asked to confirm your rollback. A deployment rollback will revert to the previously successful deployment. Both the Docker image and custom variables are restored during the rollback process. Note: Deployments older than your plan's retention policy cannot be restored via rollback, and thus the rollback option will not be visible. Redeploy A successful, failed, or crashed deployment can be re-deployed by clicking the three dots at the end of a previous deployment. This will create an new deployment with the exact same code and build/deploy configuration. Note: To trigger a deployment from the latest commit, use the Command Pallette: CMD + K -> \"Deploy Latest Commit\". This will deploy the latest commit from the Default branch in GitHub. Currently, there is no way to force a deploy from a branch other than the Default without connecting it in your service settings. Cancel Users can cancel deployments in progress by clicking the three dots at the end of the deployment tab and select Abort deployment. This will cancel the deployment in progress. Remove If a deployment is completed, you can remove it by clicking the three dots at the end of the deployment tab and select Remove. This will remove the deployment and stop any further project usage. Restart a Crashed Deployment When a Deployment is Crashed, it is no longer running because the underlying process exited with a non-zero exit code - if your deployment exits successfully (exit code 0), the status will remain Success. Railway automatically restarts crashed Deployments up to 10 times (depending on your Restart Policy). After this limit is reached, your deployment status is changed to Crashed and notifying webhooks & emails are sent to the project's members. Restart a Crashed Deployment by visiting your project and clicking on the \"Restart\" button that appears in-line on the Deployment: Restarting a crashed Deployment restores the exact image containing the code & configuration of the original build. Once the Deployment is back online, its status will change back to Success. You can also click within a deployment and using the Command Palette restart a deployment at any state. Deployment Dependencies - Startup Ordering You can control the order your services start up with Reference Variables. When one service references another, it will be deployed after the service it is referencing when applying a staged change or duplicating an environment. Services that have circular dependencies will simply ignore them and deploy as normal. For example, let's say you're deploying an API service that depends on a PostgreSQL database. When you have services with reference variables like: API Service has DATABASE_URL=${{Postgres.DATABASE_URL}} which is defined on your Postgres Service in the same project. Railway will: Deploy the Postgres Service first Then deploy the API Service (since it has a reference variable to Postgres) Prev Start CommandNext GitHub AutodeploysEdit this file on GitHub",
      "title": "Deployment Actions | Railway Docs",
      "url": "https://docs.railway.com/guides/deployment-actions"
    },
    {
      "content": "Optimize PerformanceRailway offers some quick and easy ways to configure deployments for achieving optimal performance. Specifically, we offer the following features: Horizontal Scaling with Replicas where each individual replica can use the full resources your plan allows for. (Vertical scaling is done automatically) Regional Deployments Continue reading for information on how to configure these. Configure Horizontal Scaling Scale horizontally by manually increasing the number of replicas for a service. Each replica has access to the full resources allocated by your plan. For instance, with the Pro plan, each of your replicas can utilize up to 32 vCPU and 32GB of memory, for example, if you had 2 replicas, your service would be able to utilize up to 64 vCPU and 64GB of memory split between the 2 replicas. Railway's infrastructure spans multiple regions across the globe, and by default Railway deploys to your preferred region. To change the number of replicas per deploy within your service, go to the service settings view and look for the \"Regions\" field in the \"Deploy\" section. This will create multiple instances of your service and distribute traffic between them. Additional regions may be added in the future as Railway continues expanding its infrastructure footprint. Replica ID Environment Variable Each replica will be deployed with a Railway-provided environment variable named RAILWAY_REPLICA_ID which can be used for logging and monitoring, for example. Replica Region Environment Variable Each replica will be deployed with a Railway-provided environment variable named RAILWAY_REPLICA_REGION which can be used for logging and monitoring, for example. Load Balancing Between Replicas If you are using multi-region replicas, Railway will automatically route public traffic to the nearest region and then randomly distribute requests to the replicas within that region. If you are using a single region with multiple replicas, Railway will randomly distribute public traffic to the replicas of that region. Note: For now Railway does not support sticky sessions nor report the usage of the individual replicas within the metrics view, all metrics are aggregated across all replicas in all regions. Set a Preferred Region To set a default or preferred region, do so from your Workspace Settings. Impact of Region Changes For information on the impact of changing a service's region, see the Regions reference guide. Singleton Deploys By default, Railway maintains only one deploy per service.Prev GitHub AutodeploysNext HealthchecksEdit this file on GitHub",
      "title": "Optimize Performance | Railway Docs",
      "url": "https://docs.railway.com/guides/optimize-performance"
    },
    {
      "content": "Free TrialNew users can take the platform for a spin by starting a free trial. The trial gives access to basic features and includes a one-time grant of $5. Full vs Limited Trial Your trial experience depends on whether Railway can verify your account. Trial TypeDeploy CodeDeploy DatabasesFull Trial\u2705\u2705Limited Trial\u274c\u2705 When you sign up for a free Trial, you can connect your GitHub account to initiate verification. Your verification status depends on a number of factors, including the age and activity of your GitHub account. If your account is not verified \u2014 either because you have not initiated the verification process or your account does not meet our criteria for verification \u2014 your trial experience will be limited to deploying databases. Verification is a necessary measure to prevent abuse of the free Trial, limiting users from creating multiple accounts and reducing the risk of trial users deploying or hosting content that violates Railway's Terms of Service. This is a fully automated process, and Railway does not respond to requests for verification. If your account is not verified, you can upgrade to the Hobby plan to unlock the full Railway experience. FAQs How do I get started with the free Trial? If you do not already have a Railway account, you can sign up for a free Trial by clicking \"Login\" at railway.com. How does the Trial work? When you sign up for the free Trial, you will receive a one-time grant of $5 in credits that you can use to try out Railway. The credits will be applied towards any usage on the platform and expire in 30 days. If you upgrade to a plan while you still have a credit balance from the trial, the remaining balance will carry over to your new plan. What resources can I access during the Trial? During the trial, you can access the same features as on the Hobby plan, however you will be limited to 1 GB of RAM and shared (rather than dedicated) vCPU cores. Additionally, your projects will be limited to 5 services per project. As a trial user, you can always spin-up databases. However, to deploy code, you must be on the Full Trial. What's the difference between the Limited Trial and the Full Trial? If you connect your GitHub account, and we are able to verify it against a set of parameters, you will be on the Full Trial where you can deploy both code and databases. If you do not connect a GitHub account, or we are not able to verify your account, you will be on the Limited Trial, where you can only deploy databases. While you're on the Limited Trial, you can initiate verification at any time by visiting railway.com/verify in order to access the Full Trial experience. How far will the $5 one-time Trial grant last? The longevity of your one-time trial grant depends on how many resources you consume within the 30 day period you sign-up for the platform. The more resources you deploy, the greater the consumption. Data Retention Railway deletes stateful volumes created by Trial accounts 30 days after the expiration of your credits. To retain your data, upgrade your account after the Trial period.Prev PlansNext FAQsEdit this file on GitHub",
      "title": "Free Trial | Railway Docs",
      "url": "https://docs.railway.com/reference/pricing/free-trial"
    },
    {
      "content": "Deploy a Ruby on Rails AppRails is a Ruby full-stack framework designed to compress the complexity of modern web apps. It ships with all the tools needed to build amazing web apps on both the front and back end. Create a Rails App Note: If you already have a Rails app locally or on GitHub, you can skip this step and go straight to the Deploy Ruby on Rails App on Railway. To create a new Rails app, ensure that you have Ruby and Rails installed on your machine. Once everything is set up, run the following command in your terminal: rails new blog --database=postgresql This command will create a new Rails app named blog with PostgreSQL as the database config. Now, let\u2019s create a simple \"Hello World\" page to ensure everything is working correctly. Generate a Controller: Run the following command to create a new controller named HelloWorld with an index action: rails g controller HelloWorld index This will generate the necessary files for the controller, along with a view, route, and test files. Update the Routes File: Open the config/routes.rb file and modify it to set the root route to the hello_world#index action: Rails.application.routes.draw do get \"hello_world/index\" # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500. # Can be used by load balancers and uptime monitors to verify that the app is live. get \"up\" => \"rails/health#show\", as: :rails_health_check # Render dynamic PWA files from app/views/pwa/* get \"service-worker\" => \"rails/pwa#service_worker\", as: :pwa_service_worker get \"manifest\" => \"rails/pwa#manifest\", as: :pwa_manifest # Defines the root path route (\"/\") root \"hello_world#index\" end Modify the View: Open the app/views/hello_world/index.html.erb file and replace its content with the following: <h1>Hello World</h1> <p> This is a Rails app running on Railway</p> Run the Application Locally: Start the Rails server by running: bin/rails server Open your browser and go to http://localhost:3000 to see your \"Hello World\" page in action. Now that your app is running locally, let\u2019s move on to deploying it to Railway! Deploy Ruby on Rails App on Railway Railway offers multiple ways to deploy your Rails app, depending on your setup and preference. Choose any of the following methods: One-click deploy from a template. Using the CLI. From a GitHub repository. One-Click Deploy from a Template If you\u2019re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Rails app along with a Postgres database and Redis. Click the button below to begin: After deploying, we recommend that you eject from the template to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project. Deploy from the CLI To deploy the Rails app using the Railway CLI, please follow the steps: Install the Railway CLI: Install the CLI and authenticate it using your Railway account. Initialize a Railway Project: Run the command below in your Rails app directory. railway init Follow the prompts to name your project. After the project is created, click the provided link to view it in your browser. Deploy the Application: Use the command below to deploy your app: railway up This command will scan, compress and upload your app's files to Railway. You\u2019ll see real-time deployment logs in your terminal. Note: If you see an error about a missing secret_key_base for the production environment, don\u2019t worry. We\u2019ll fix this in the next step. Add a Database Service: Run railway add. Select PostgreSQL by pressing space and hit Enter to add it to your project. A database service will be added to your Railway project. Configure Environment Variables: Go to your app service Variables section and add the following: SECRET_KEY_BASE or RAILS_MASTER_KEY: Set the value to the key from your local app's config/master.key. DATABASE_URL: Set the value to ${{Postgres.DATABASE_PUBLIC_URL}} (this references the URL of your new Postgres database). Learn more about referencing service variables. Use the Raw Editor to add any other required environment variables in one go. Redeploy the Service: Click Deploy on the Railway dashboard to apply your changes. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Note: If your app has a Dockerfile (which newer Rails apps typically include by default), Railway will automatically detect and use it to build your app. If not, Railway will still handle the deployment process for you. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Deploy from a GitHub Repo To deploy the Rails app to Railway, start by pushing the app to a GitHub repo. Once that\u2019s set up, follow the steps below to complete the deployment process. Create a New Project on Railway: Go to Railway to create a new project. Deploy from GitHub: Select Deploy from GitHub repo and choose your repository. If your Railway account isn\u2019t linked to GitHub yet, you\u2019ll be prompted to do so. Add Environment Variables: Click Add Variables and configure all the necessary environment variables for your app. E.g RAILS_ENV: Set the value to production. E.g SECRET_KEY_BASE or RAILS_MASTER_KEY: Set the value to the key from your app's config/master.key. Deploy the App: Click Deploy to start the deployment process. Once the deployed, a Railway service will be created for your app, but it won\u2019t be publicly accessible by default. Add a Database Service: Right-click on the Railway project canvas or click the Create button. Select Database. Select Add PostgreSQL from the available databases. This will create and deploy a new Postgres database service for your project. Configure Environment Variables: Go to your app service Variables section and add the following: DATABASE_URL: Set the value to ${{Postgres.DATABASE_URL}} (this references the URL of your new Postgres database). Learn more about referencing service variables. Use the Raw Editor to add any other required environment variables in one go. Prepare Database and Start Server: Go to your app service Settings section. In the Deploy section, set bin/rails db:prepare && bin/rails server -b :: as the Custom Start Command. This command will run your database migrations and start the server. Redeploy the Service: Click Deploy on the Railway dashboard to apply your changes. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Note: During the deployment process, Railway will automatically detect that it\u2019s a Rails app. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. This guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Rails apps effortlessly! Next, we'll cover how to set up workers and cron jobs for your Rails app on Railway. Set Up Workers & Cron Jobs with Sidekiq Sidekiq is a powerful and efficient background job processor for Ruby apps, and it integrates seamlessly with Rails. Follow the instructions below to configure and run Sidekiq in your Rails app on Railway: Install Sidekiq Start by adding sidekiq and sidekiq-cron to your Rails app. In your terminal, run the following command: bundle add sidekiq bundle add sidekiq-cron Add a Redis Database Service Sidekiq uses Redis as a job queue. To set this up: Right-click on the Railway project canvas or click the Create button. Select Database. Select Add Redis from the available databases. This will create and deploy a new Redis service for your app. Create and Configure a Worker Service Now, set up a separate service to run your Sidekiq workers. Create a new Empty Service and name it Worker Service. Go to the Settings tab of this service to configure it. In the Source section, connect your GitHub repository to the Source Repo. Under the Build section, set bundle install as the Custom Build Command. This installs the necessary dependencies. In the Deploy section, set bundle exec sidekiq as the Custom Start Command. This command will start Sidekiq and begin processing jobs. Click on Variables at the top of the service settings. Add the following environment variables: RAILS_ENV: Set the value to production. SECRET_KEY_BASE or RAILS_MASTER_KEY: Set this to the value of your Rails app\u2019s secret key. REDIS_URL: Set this to ${{Redis.REDIS_URL}} to reference the Redis database URL. This tells Sidekiq where to find the job queue. Learn more about referencing service variables. Include any other environment variables your app might need. Click Deploy to apply the changes and start the deployment. Verify the Deployment: Once the deployment is complete, click on View Logs. If everything is set up correctly, you should see Sidekiq starting up and processing any queued jobs. Confirm All Services Are Connected: At this stage, your application should have the following services set up and connected: App Service: Running the main Rails application. Worker Service: Running Sidekiq to process background jobs. Postgres Service: The database for your Rails app. Redis Service: Used by Sidekiq to manage background jobs Here\u2019s how your setup should look: By following these steps, you\u2019ll have a fully functional Rails app with background job processing using Sidekiq on Railway. If you run into any issues or need to make adjustments, check the logs and revisit your environment variable configurations. Next Steps Explore these resources to learn how you can maximize your experience with Railway: Monitoring Deployments Prev GinNext AxumEdit this file on GitHub",
      "title": "Deploy a Ruby on Rails App | Railway Docs",
      "url": "https://docs.railway.com/guides/rails"
    },
    {
      "content": "Railway vs. VercelAt a high level, both Railway and Vercel enable you to deploy your app without the hassle of managing infrastructure. Both platforms share several similarities: Git-based automated deployments with support for instant rollbacks. Automatic preview environments. Built-in observability. Autoscaling resources with usage-based pricing. That said, there are fundamental differences between both platforms, and certain use cases where Railway is a better fit. Understanding the underlying infrastructure and ideal use cases Vercel\u2019s infrastructure Vercel has developed a proprietary deployment model where infrastructure components are derived from the application code (see Framework-defined infrastructure). At build time, application code is parsed and translated into the necessary infrastructure components. Server-side code is then deployed as serverless functions, powered by AWS under the hood. To handle scaling, Vercel creates a new function instance for each incoming request with support for concurrent execution within the same instance (see Fluid compute). Over time, functions scale down to zero to save on compute resources. This deployment model abstracts away infrastructure, but introduces limitations: Memory limits: the maximum amount of memory per function is 4GB. Execution time limit: the maximum amount of time a function can run is 800 seconds (~13.3 minutes). Size\u00a0(after gzip compression): the maximum is 250 MB. Cold starts: when a function instance is created for the first time, there\u2019s an amount of added latency. Vercel includes several optimizations, which reduces cold start frequency but won\u2019t completely eliminate them. If you plan on running long-running workloads such as: Data Processing: ETL jobs, large file imports/exports, analytics aggregation. Media Processing: Video/audio transcoding, image resizing, thumbnail generation. Report Generation: Creating large PDFs, financial reports, user summaries. DevOps/Infrastructure: Backups, CI/CD tasks, server provisioning. Billing & Finance: Usage calculation, invoice generation, payment retries. User Operations: Account deletion, data merging, stat recalculations. Or if you plan on running workloads that require a persistent connection such as: Chat messaging: Live chats, typing indicators. Live dashboards: Metrics, analytics, stock tickers. Collaboration: Document editing, presence. Live tracking: Delivery location updates. Push notifications: Instant alerts. Voice/video calls: Signaling, status updates. Then deploying your backend services to Vercel functions will not be the right fit. Railway\u2019s infrastructure Railway's underlying infrastructure runs on hardware that\u2019s owned and operated in data centers across the globe. By controlling the hardware, software, and networking stack end to end, the platform delivers best-in-class performance, reliability, and powerful features, all while keeping costs in check. Railway uses a custom builder that takes your source code or Dockerfile and automatically builds and deploys it, without needing configuration. Your code runs on a long-running server, making it ideal for apps that need to stay running or maintain a persistent connection. All deployments come with smart defaults out of the box, but you can tweak things as needed. This makes Railway flexible across different runtimes and programming languages. Each service you deploy can automatically scale up vertically to handle incoming workload. You also get the option to horizontally scale a service by spinning up replicas. Replicas can be deployed in multiple regions simultaneously. You can also set services to start on a schedule using a crontab expression. This lets you run scripts at specific times and only pay for the time they\u2019re running. Pricing model differences Both platforms follow a usage-based pricing model, but are different due to the underlying infrastructure. Vercel Vercel functions are billed based on: Active CPU: Time your code actively runs in milliseconds Provisioned memory: Memory held by the function instance, for the full lifetime of the instance Invocations: number of function requests, where you\u2019re billed per request Each pricing plan includes a certain allocation of these metrics. This makes it possible for you to pay for what you use. However, since Vercel runs on AWS, the unit economics of the business need to be high to offset the cost of the underlying infrastructure. Those extra costs are then passed down to you as the user, so you end up paying extra for resources such as bandwidth, memory, CPU and storage. Railway Railway follows a usage-based pricing model that depends on how long your service runs and the amount of resources it consumes. Active compute time x compute size (memory and CPU) If you spin up multiple replicas for a given service, you\u2019ll only be charged for the active compute time for each replica. Railway also has a serverless feature, which helps further reduce costs when enabled. When a service has no outbound requests for over 10 minutes, it is automatically put to sleep. While asleep, the service incurs no compute charges. It wakes up on the next incoming request, ensuring seamless reactivation without manual effort. This makes it ideal for sporadic or bursty workloads, giving you the flexibility of a full server with the cost efficiency of serverless, with the benefit of only paying when your code is running. Deployment experience Vercel Managing multiple services In Vercel, a project maps to a deployed application. If you would like to deploy multiple apps, you\u2019ll do it by creating multiple projects. Integrating your application with external services If you would like to integrate your app with other infrastructure primitives (e.g storage solutions for your application\u2019s database, caching, analytical storage, etc.), you can do it through the Vercel marketplace. This gives you an integrated billing experience, however managing services is still done by accessing the original service provider. Making it necessary to switch back and forth between different dashboards when you\u2019re building your app. Railway Managing projects In Railway, a project is a collection of services and databases. This can include frontend, API, background workers, API, analytics database, queues and so much more. All in a unified deployment experience that supports real-time collaboration. Databases Additionally, Railway has first-class support for Databases. You can one-click deploy any open-source database: Relational: Postgres, MySQL Analytical: Clickhouse, Timescale Key-value: Redis, Dragonfly Vector: Chroma, Weviate Document: MongoDB Check out all of the different storage solutions you can deploy. Template directory Finally, Railway offers a template directory that makes it easy to self-host open-source projects with just a few clicks. If you publish a template and others deploy it in their projects, you\u2019ll earn a 50% kickback of their usage costs. Check out all templates at railway.com/deploy Summary FeatureRailwayVercelInfrastructure ModelLong-running servers on dedicated hardwareServerless functions on AWSScalingVertical + horizontal scaling with replicasScales via stateless function instancesPersistent Connections\u2705 Yes (sockets, live updates, real-time apps)\u274c UnsupportedCold Starts\u274c No cold starts\u26a0\ufe0f Possible cold starts (with optimizations)Max Memory LimitUp to full machine capacity4GB per functionExecution Time LimitUnlimited (as long as the process runs)800 seconds (13.3 minutes)DatabasesBuilt-in one-click deployments for major databasesIntegrated via marketplace (external providers)Project StructureUnified project: multiple services + databases in oneOne service per projectUsage-Based BillingBased on compute time and size per replicaBased on CPU time, memory provisioned, and invocationsIdeal ForFullstack apps, real-time apps, backend servers, long-running tasksFrontend-first apps, short-lived APIsSupport for Docker\u2705 Yes\u274c No (function-based only) Migrate from Vercel to Railway To get started, create an account on Railway. You can sign up for free and receive $5 in credits to try out the platform. Deploying your app \u201cChoose Deploy from GitHub repo\u201d, connect your GitHub account, and select the repo you would like to deploy. If your project is using any environment variables or secrets: Click on the deployed service. Navigate to the \u201cVariables\u201d tab. Add a new variable by clicking the \u201cNew Variable\u201d button. Alternatively, you can import a .env file by clicking \u201cRaw Editor\u201d and adding all variables at once. To make your project accessible over the internet, you will need to configure a domain: From the project\u2019s canvas, click on the service you would like to configure. Navigate to the \u201cSettings\u201d tab. Go to the \u201cNetworking\u201d section. You can either: Generate a Railway service domain: this will make your app available under a .up.railway.app domain. Add a custom domain: follow the DNS configuration steps. Need help or have questions? If you need help along the way, the Railway Discord and Help Station are great resources to get support from the team and community. Working with a larger workload or have specific requirements? Book a call with the Railway team to explore how we can best support your project.Prev Compare to FlyNext Compare to DigitalOceanEdit this file on GitHub\n\n--- TEXT FROM IMAGES ---\n\nImage: https://res.cloudinary.com/railway/image/upload/v1753470541/docs/comparison-docs/vercel-fluid-compute_kiitdu.png\nAlt text: https://vercel.com/blog/introducing-fluid-compute\nOCR text: Traditional Serverless Fluid Vercel Functions \\ | Invocation 1 @cComplete | i \\ H Invocation 1 @ complete |! . re ' Invocation 2 Olde | Invocation 2 @idie | i ' Invocation 3 31. Active | ' Invocation 3 31. Active j\n\nImage: https://res.cloudinary.com/railway/image/upload/v1753470545/docs/comparison-docs/railway-regions_syr9jf.png\nAlt text: Railway regions\nOCR text: Railway Regions Railway's infrastructure spans multiple regions across the... [truncated]",
      "title": "Railway vs. Vercel | Railway Docs",
      "url": "https://docs.railway.com/maturity/compare-to-vercel"
    },
    {
      "content": "Deploy a Nuxt AppNuxt is a Vue.js framework that makes web development intuitive and powerful. You can create performant and production-grade full-stack web apps and websites with confidence. Nuxt is known as The Intuitive Vue Framework because it simplifies building Vue.js applications with features like server-side rendering and easy routing. This guide covers how to deploy a Nuxt app to Railway in four ways: One-click deploy from a template. From a GitHub repository. Using the CLI. Using a Dockerfile. Now, let's create a Nuxt app! Create a Nuxt App Note: If you already have a Nuxt app locally or on GitHub, you can skip this step and go straight to the Deploy Nuxt App on Railway. To create a new Nuxt app, ensure that you have Node installed on your machine. Run the following command in your terminal to create a new Nuxt app: npx nuxi@latest init helloworld A new Nuxt app will be provisioned for you in the helloworld directory. Run the Nuxt App locally Next, cd into the directory and start the development server by running the following command: npm run dev Open your browser and go to http://localhost:3000 to see your app. Deploy the Nuxt App to Railway Railway offers multiple ways to deploy your Nuxt app, depending on your setup and preference. One-Click Deploy from a Template If you\u2019re looking for the fastest way to get started, the one-click deploy option is ideal. Click the button below to begin: We highly recommend that you eject from the template after deployment to create a copy of the repo on your GitHub account. Note: You can also choose from a variety of Nuxt app templates created by the community. Deploy from the CLI Install the Railway CLI: Install the CLI and authenticate it using your Railway account. Initialize a Railway Project: Run the command below in your Vue app directory. railway init Follow the prompts to name your project. After the project is created, click the provided link to view it in your browser. Modify Package.json Config: By default, Nuxt doesn't add a start script in the package.json file. We'll need to add that to instruct Railway on how to run our app. Add \"start\":\"node .output/server/index.mjs\" to the package.json file. package.json { \"name\": \"nuxt-app\", \"private\": true, \"type\": \"module\", \"scripts\": { \"build\": \"nuxt build\", \"dev\": \"nuxt dev\", \"start\": \"node .output/server/index.mjs\", \"generate\": \"nuxt generate\", \"preview\": \"nuxt preview\", \"postinstall\": \"nuxt prepare\" }, \"dependencies\": { \"nuxt\": \"^3.13.0\", \"vue\": \"latest\", \"vue-router\": \"latest\" } } Note: Railway uses Nixpacks to build and deploy your code with zero configuration. The Nixpack Node provider will pick up the start script in the package.json file and use it to serve the app. Deploy the Application: Use the command below to deploy your app: railway up This command will scan, compress and upload your app's files to Railway. You\u2019ll see real-time deployment logs in your terminal. Once the deployment completes, go to View logs to check if the service is running successfully. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Deploy from a GitHub Repo To deploy a Nuxt app to Railway directly from GitHub, follow the steps below: Create a New Project on Railway: Go to Railway to create a new project. Modify Package.json Config: Follow step 3 mentioned in the CLI guide Deploy from GitHub: Select Deploy from GitHub repo and choose your repository. If your Railway account isn\u2019t linked to GitHub yet, you\u2019ll be prompted to do so. Deploy the App: Click Deploy to start the deployment process. Once the deployed, a Railway service will be created for your app, but it won\u2019t be publicly accessible by default. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Use a Dockerfile Create a Dockerfile in the helloworld or Nuxt app's root directory. Add the content below to the Dockerfile: # Use the Node alpine official image # https://hub.docker.com/_/node FROM node:lts-alpine AS build # Create and change to the app directory. WORKDIR /app # Copy the files to the container image COPY package*.json ./ # Install packages RUN npm ci # Copy local code to the container image. COPY . ./ # Build the app. RUN npm run build # Copy files to the container image. COPY --from=build /app ./ # Serve the app CMD [\"npm\", \"run\", \"start\"] Either deploy via the CLI or from GitHub. Railway automatically detects the Dockerfile, and uses it to build and deploy the app. Note: Railway supports also deployment from public and private Docker images. This guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Nuxt apps seamlessly! Next Steps Explore these resources to learn how you can maximize your experience with Railway: Add a Database Service Monitor your app Prev VueNext Spring BootEdit this file on GitHub",
      "title": "Deploy a Nuxt App | Railway Docs",
      "url": "https://docs.railway.com/guides/nuxt"
    },
    {
      "content": "Deploy a Remix AppRemix is a full-stack web framework that empowers you to build fast, elegant, and resilient user experiences by focusing on the interface and working seamlessly with web standards. Your users will enjoy every moment spent with your product. This guide covers how to deploy a Remix app to Railway in four ways: One-click deploy from a template. From a GitHub repository. Using the CLI. Using a Dockerfile. Now, let's create a Remix app! Create a Remix App Note: If you already have a Remix app locally or on GitHub, you can skip this step and go straight to the Deploy Remix App on Railway. To create a new Remix app, ensure that you have Node installed on your machine. Run the following command in your terminal to create a new Remix app: npx create-remix@latest Follow the prompts by giving a directory name, like helloworld, where you want your app to be set up. When asked, select Yes to automatically install all the necessary dependencies. A new Remix app will be provisioned for you in the helloworld directory. Run the Remix App locally Start the Vite development server by running the following command: npm run dev Open your browser and go to http://localhost:5173 to see your app. Deploy the Remix App to Railway Railway offers multiple ways to deploy your Remix app, depending on your setup and preference. One-Click Deploy from a Template If you\u2019re looking for the fastest way to get started, the one-click deploy option is ideal. Click the button below to begin: We highly recommend that you eject from the template after deployment to create a copy of the repo on your GitHub account. Note: You can also choose from a variety of Remix app templates created by the community. Deploy from the CLI Install the Railway CLI: Install the CLI and authenticate it using your Railway account. Initialize a Railway Project: Run the command below in your Vue app directory. railway init Follow the prompts to name your project. After the project is created, click the provided link to view it in your browser. Deploy the Application: Use the command below to deploy your app: railway up This command will scan, compress and upload your app's files to Railway. You\u2019ll see real-time deployment logs in your terminal. Once the deployment completes, go to View logs to check if the service is running successfully. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Deploy from a GitHub Repo To deploy a Remix app to Railway directly from GitHub, follow the steps below: Create a New Project on Railway: Go to Railway to create a new project. Deploy from GitHub: Select Deploy from GitHub repo and choose your repository. If your Railway account isn\u2019t linked to GitHub yet, you\u2019ll be prompted to do so. Deploy the App: Click Deploy to start the deployment process. Once the deployed, a Railway service will be created for your app, but it won\u2019t be publicly accessible by default. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Use a Dockerfile Create a Dockerfile in the helloworld or Remix app's root directory. Add the content below to the Dockerfile: # Use the Node alpine official image # https://hub.docker.com/_/node FROM node:lts-alpine # Create and change to the app directory. WORKDIR /app # Copy the files to the container image COPY package*.json ./ # Install packages RUN npm ci # Copy local code to the container image. COPY . ./ # Build the app. RUN npm run build # Serve the app CMD [\"npm\", \"run\", \"start\"] Either deploy via the CLI or from GitHub. Railway automatically detects the Dockerfile, and uses it to build and deploy the app. Note: Railway supports also deployment from public and private Docker images. This guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Remix apps seamlessly! Next Steps Explore these resources to learn how you can maximize your experience with Railway: Add a Database Service Monitor your app Prev ReactNext VueEdit this file on GitHub",
      "title": "Deploy a Remix App | Railway Docs",
      "url": "https://docs.railway.com/guides/remix"
    },
    {
      "content": "PhilosophyRailway is a deployment platform that helps developers deliver their software through the entire application life-cycle through git native tooling, composable infrastructure, and built-in instrumentation. We design and develop our product features to serve what we consider to be the three primary stages of software development: Development Deployment Diagnosis Most developer-oriented products attempt to target one or more stages within the software development cycle. Railway provides solutions for developers for all of these stages, whereas some vendors focus on specific stages. Railway is a company staffed with people who know developers would prefer to use tools they are familiar with. We believe software should be \"take what you need, and leave what you don't.\" As a result, we are comfortable recommending additional vendors if they might acutely meet their needs. Our goal is for your unique need to be served so you can focus on delivering for your customers. Companies should be as upfront as possible about their product and offerings to help you decide what is best for your team and users. Let's talk about the number one use case: delivering apps to users in a Production environment. Railway, the company, is sustainable, building our product, team, and company to last as your projects. Objective The goal of this section is to describe the processes, internal and external that companies have requested in our years of operation to help them build confidence to determine if Railway is a good fit for their company. Railway maintains a policy to be forthcoming and frank at all times. We would rather have a developer make the correct choice for their company than to adopt Railway and then come to regret that decision. If you have any additional questions or if you require any additional disclosure you can contact us to set up a call at [email\u00a0protected]. Product Philosophy Railway is focused on building an amazing developer experience. Our goal is to enable developers to deploy their code and see their work in action, without thinking about CI/CD, deployments, networking, and so forth, until they need to. Take What You Need To achieve our goal, we've designed Railway to \"just work\", with all the necessary magic built in to achieve that. Railway at a high level reads your code repo, makes a best guess effort to build it into an OCI compliant image, and runs the image with a start command. Have a code repository but have yet to think about deployment? We got you. Connect your code repository and let Railway take care of the rest. Already built the perfect Dockerfile? Bring it. If you have a Dockerfile in your repo, we'll find it and use that to build your image. If you've outgrown the \"magic\" built into deployment platforms, or are suspicious of things that are just too magical, we are happy to provide a high level overview of our architecture. Leave What You Don't Streamlined deployment workflows and sane defaults are inherited by every project in Railway out of the box; but as a team of engineers, we at Railway are very aware that what works for one project does not always work for another. Or sometimes, you just need to be in control - maybe you already have a workflow you like, or maybe you need to layer Railway into existing infrastructure, and abstractions only get in your way. That's why we've designed the platform for flexibility, wherever you need it. On Railway, you can use the default pattern for deployment or opt to use vendor. In fact, we will even support you in your effort to integrate Railway in a unique way. Here are a couple of use cases we've helped customers take advantage of - Deploying to Railway from Gitlab CI/CD Supporting the development of a Terraform provider Region based routing to workloads via Cloudflare We love working with our customers to solve interesting use cases. If you're not seeing a track for you, get in touch at [email\u00a0protected] and we'll find it! High-level Architecture As mentioned before, Railway at a high level takes your code, builds it, and throws it on running infrastructure on GCP. At a granular level Railway relies on a few systems to maintain workloads. Build Layer Where archived folders of code or a Dockerfile (via GitHub or railway up) is sent to be built into an image Nixpacks: the OSS software that reads your code and builds it via Nix Image Registry: either via Dockerhub/GitHub packages, or a previously built image from Railway's Build servers Deployment Layer Where images are ran in containers, images are pulled from the Build Layer Databases on Railway are images + volumes mounted on a machine Cron services are containers ran on a defined schedule Routing Layer This is the system that Railway maintains that routes requests into your running containers and provides private networks to suites of containers. Logging Layer A suite of machines networked running Clickhouse that store container logs. This is accessed when you open the service logs pane. Dashboard Layer Infrastructure and code that is used to manage the above layers. This also incudes any monitors that Railway uses to maintain the state of the Deployment Layer to maintain application state. (ex. Removing a deployment.) Your code will either be in some, or all steps depending on the amount of Railway that you choose to adopt. Operational Procedures Railway uses a suite of alerting vendors, additional internal tools, and PagerDuty to ensure uptime of our services described above. You can see Railway's uptime on our Instatus page. Operational incident management reports and RCAs are available by request for those on an Enterprise plan. Do I have to change how I write code? No, Railway is a deployment platform that works with your existing code. We don't require you to change how you write code or use any specific frameworks. We support all languages and frameworks that can be run in a Docker container or within Nixpacks. Is Railway serverless? No, services on Railway are deployed in stateful Docker containers. The old deployments are removed on every new deploy. We do have a feature, App Sleeping, that allows you to configure your service to \"sleep\" when it is inactive, and therefore will stop it from incurring usage cost while not in use. Book a Demo If you're looking to adopt Railway for your business, we'd love to chat and ensure your questions are answered. Click here to book some time with us.Prev Production Readiness ChecklistNext Use CasesEdit this file on GitHub",
      "title": "Philosophy | Railway Docs",
      "url": "https://docs.railway.com/maturity/philosophy"
    },
    {
      "content": "Using Config as CodeRailway supports defining the configuration for a single deployment in a file alongside your code in a railway.toml or railway.json file. Everything in the build and deploy sections of the service settings page can be specified in this configuration file. The settings in the dashboard will not be updated with the settings defined in code. Configuration defined in code will always override values from the dashboard. Toml vs Json The format you use for your config-as-code (toml or json) file is entirely dependent on preference, and the resulting behavior in Railway is the same no matter which you choose. For example, these configuration definitions are equivalent: [build] builder = \"nixpacks\" buildCommand = \"echo building!\" [deploy] preDeployCommand = [\"npm run db:migrate\"] startCommand = \"echo starting!\" healthcheckPath = \"/\" healthcheckTimeout = 100 restartPolicyType = \"never\" --A railway.toml file{ \"$schema\": \"https://railway.com/railway.schema.json\", \"build\": { \"builder\": \"NIXPACKS\", \"buildCommand\": \"echo building!\" }, \"deploy\": { \"preDeployCommand\": [\"npm run db:migrate\"], \"startCommand\": \"echo starting!\", \"healthcheckPath\": \"/\", \"healthcheckTimeout\": 100, \"restartPolicyType\": \"never\" } }A railway.json file JSON Schema You can find an always up-to-date JSON schema at railway.com/railway.schema.json. If you include it in your railway.json file, many editors (e.g. VSCode) will provide autocomplete and documentation. { \"$schema\": \"https://railway.com/railway.schema.json\" } Understanding Config Source On a service's deployment details page, all the settings that a deployment went out with are shown. For settings that come from a configuration file, there is a file icon. Hovering over the icon will show exactly what part of the file the values originated from. Using a Custom Config as Code File You can use a custom config file by setting it on the service settings page. The file is relative to your app source. Configurable Settings Find a list of all of the configurable settings in the config as code reference page.Prev Manage VariablesNext Getting StartedEdit this file on GitHub",
      "title": "Using Config as Code | Railway Docs",
      "url": "https://docs.railway.com/guides/config-as-code"
    },
    {
      "content": "Database ServicesReady for databases? Railway's platform primitives are built with flexibility in mind, allowing you to build any type of service your system requires, including database services. Feature Highlights Essential FeaturesRailway has developed some essential features for enabling any type of database service to run in Railway - Volumes for persisting your data, and TCP Proxy for facilitating communication to your database from the internet.Database TemplatesNot only is our Template Marketplace filled with many different database service templates, but Railway also maintains several templates for some of the most popular databases out there - PostgreSQL, MySQL, MongoDB, and Redis. Use the next few pages to understand how to build your own database service or how to use the templates available. Note that the Railway-provided databases are still considered unmanaged services, meaning you will need to take the appropriate steps to ensure they are optimized for your usecase.Prev Optimize UsageNext Build a Database ServiceEdit this file on GitHub",
      "title": "Database Services | Railway Docs",
      "url": "https://docs.railway.com/guides/databases"
    },
    {
      "content": "The Conductor ProgramThe Conductor Program brings together the amazing people who make Railway's community special. Conductors shepherd the experience for our 45K+ community members. They are the bridge between the Railway team and our thriving community. This program aims to foster collaboration and help our Conductors grow. What Do Conductors Do? Our Conductors spend time in Discord and the Central Station answering questions, sharing tips, and making sure everyone can use Railway successfully. Here are a few key ways they contribute - Providing community support through Discord and the Central Station. Maintaining a healthy and welcoming community atmosphere while moderating our channels and templates. Contributing to Railway's open-source projects through improvements and new features. Creating a direct feedback loop between users and the Railway team. Through these activities, Conductors ensure everyone can use Railway successfully while helping to build a collaborative and supportive community environment. Ready to Become a Conductor? Are you passionate about helping others and love being part of Railway's community? We're always excited to welcome new Conductors who share our enthusiasm for community engagement! Here's what we look for in potential Conductors - Have demonstrated experience with Railway's platform and services. Show a consistent track record of helping others in our community. Maintain professional and friendly communication. Are active participants in our Discord and Central Station. Demonstrate strong technical problem-solving abilities. The ideal Conductor combines technical expertise with mentorship skills to help our community thrive! Apply Now Conductor Benefits Being a Conductor comes with several exciting perks and rewards to recognize your valuable contributions to the community. As part of the program, conductors will receive - 100% off discount for the Hobby plan's subscription and resource costs. Cash payouts for solving complex issues for users. The opportunity to earn payouts for OSS contributions (CLI, Nixpacks, Docs, etc). First access to template bounties. Letters of recommendation for educational institutions and employer references. Moderation status on Discord and the Central Station. Access to a team workspace shared with other Conductors. A direct line to the team via the private Conductor only channel. Your choice of Railway Swag. And to top it all off, each quarter we reward our most outstanding conductor with a pizza party! \ud83c\udf89 Conductor Participation We believe in fostering an active and supportive Conductor program that enables everyone to make meaningful contributions. To help keep our community vibrant, we conduct friendly quarterly check-ins with all Conductors. As a Conductor, you'll contribute regularly in these key areas - Community Engagement Being an active, welcoming presence in community channels. Building connections with fellow community members. Joining community conversations and sharing experiences. Looking out for the community by making sure discussions stay positive and helpful. Support Activities Helping others in Discord and the Central Station. Showing consistent engagement by regularly contributing to meaningful solutions across all Railway platforms. Open Source Contributions Contributing through either small improvements or substantial feature additions. New features should address community-requested needs with demonstrated user demand. Bug fixes should focus on issues affecting multiple users. We understand that maintaining consistent participation across these areas requires dedication and time. As part of our commitment to supporting Conductors, we have quarterly check-ins to discuss your experience and ensure you have everything needed to succeed. While we aim for regular engagement, we recognize that life circumstances and priorities can change. If participation becomes limited, we may need to transition members out of the program during our bi-annual review. However, our door always remains open \u2013 former Conductors are welcome to rejoin the program when their schedule better accommodates regular participation!Prev Migrate from HerokuNext Affiliate ProgramEdit this file on GitHub",
      "title": "The Conductor Program | Railway Docs",
      "url": "https://docs.railway.com/community/the-conductor-program"
    },
    {
      "content": "Deploy a Laravel AppLaravel is a PHP framework designed for web artisans who value simplicity and elegance in their code. It stands out for its clean and expressive syntax, and offers built-in tools to handle many common tasks found in modern web applications, making development smoother and more enjoyable. This guide covers how to deploy a Laravel app on Railway in three ways: One-click deploy from a template. From a GitHub repository. Using the CLI. One-Click Deploy From a Template This template sets up a basic Laravel application along with a Postgres database on Railway. You can also choose from a variety of Laravel app templates created by the community. We highly recommend that you eject from the template after deployment to create a copy of the repo on your GitHub account. Deploy From a GitHub Repo To deploy a Laravel app on GitHub to Railway, follow the steps below: Create a New Project. Click Deploy from GitHub repo. Select your GitHub repo. Railway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it. Click Add Variables. Add all your app environment variables. Click Deploy. Once the deployment is successful, a Railway service will be created for you. By default, this service will not be publicly accessible. Note: Railway will automatically detect that it's a Laravel app during deploy and run your app via php-fpm and nginx. To set up a publicly accessible URL for the service, navigate to the Networking section in the Settings tab of your new service and click on Generate Domain. Note: Jump to the Set Up Database, Migrations, Crons and Workers section to learn how to run your Laravel app along with a Postgres(or MySQL) database, cron jobs, and workers. Deploy From the CLI If you have your Laravel app locally, you can follow these steps: Install and authenticate with the Railway CLI. Run railway init within your Laravel app root directory to create a new project on Railway. Follow the steps in the prompt to give your project a name. Run railway up to deploy. The CLI will now scan, compress and upload our Laravel app files to Railway's backend for deployment. Your terminal will display real-time logs as your app is being deployed on Railway. Once the deployment is successful, click on View logs on the recent deployment on the dashboard. You'll see that the server is running. However you'll also see logs prompting you to add your env variables. Click on the Variables section of your service on the Railway dashboard. Click on Raw Editor and add all your app environment variables. Click on Deploy to redeploy your app. To set up a publicly accessible URL for the service, navigate to the Networking section in the Settings tab of your new service and click on Generate Domain. Note: The next step shows how to run your Laravel app along with a database, migrations, cron jobs, and workers. Set Up Database, Migrations, Crons and Workers This setup deploys your Laravel app on Railway, ensuring that your database, scheduled tasks (crons), and queue workers are all fully operational. The deployment structure follows a \"majestic monolith\" architecture, where the entire Laravel app is managed as a single codebase but split into four separate services on Railway: App Service: Handles HTTP requests and user interactions. Cron Service: Manages scheduled tasks (e.g., sending emails or running reports). Worker Service: Processes background jobs from the queue. Database Service: Stores and retrieves your application's data. My Majestic Monolith Laravel app Please follow these steps to get started: Create four bash scripts in the root directory of your Laravel app: build-app.sh, run-worker.sh, and run-cron.sh. These scripts will contain the commands needed to deploy and run the app, worker, and cron services for your Laravel app on Railway. Add the content below to the build-app.sh file: Note: You can add any additional commands to the script that you want to run each time your app service is built. #!/bin/bash # Make sure this file has executable permissions, run `chmod +x build-app.sh` # Exit the script if any command fails set -e # Build assets using NPM npm run build # Clear cache php artisan optimize:clear # Cache the various components of the Laravel application php artisan config:cache php artisan event:cache php artisan route:cache php artisan view:cache Add the content below to the run-worker.sh file: #!/bin/bash # Make sure this file has executable permissions, run `chmod +x run-worker.sh` # This command runs the queue worker. # An alternative is to use the php artisan queue:listen command php artisan queue:work Add the content below to the run-cron.sh file: #!/bin/bash # Make sure this file has executable permissions, run `chmod +x run-cron.sh` # This block of code runs the Laravel scheduler every minute while [ true ] do echo \"Running the scheduler...\" php artisan schedule:run --verbose --no-interaction & sleep 60 done Create a Postgres Database service on the Project Canvas. Click on Deploy. Create a new service on the Project Canvas. Name the service App service, and click on Settings to configure it. Connect your GitHub repo to the Source Repo in the Source section. Add chmod +x ./build-app.sh && sh ./build-app.sh to the Custom Build Command in the Build section. Add php artisan migrate to the Pre-Deploy Command in the Deploy section. Head back to the top of the service and click on Variables. Add all the necessary environment variables required for the Laravel app especially the ones listed below. APP_KEY: Set the value to what you get from the php artisan key:generate command. DB_CONNECTION: Set the value to pgsql. QUEUE_CONNECTION: Set the value to database. DB_URL: Set the value to ${{Postgres.DATABASE_URL}} (this references the URL of your new Postgres database). Learn more about referencing service variables. Click Deploy. Create a new service on the Project Canvas. Name the service cron service, and click on Settings. Connect your GitHub repo to the Source Repo in the Source section. Add chmod +x ./run-cron.sh && sh ./run-cron.sh to the Custom Start Command in the Deploy section. Head back to the top of the service and click on Variables. Add all the necessary environment variables especially those highlighted already in step 3. Click Deploy. Create a new service again on the Project Canvas. Name the service worker service, and click on Settings. Connect your GitHub repo to the Source Repo in the Source section. Add chmod +x ./run-worker.sh && sh ./run-worker.sh to the Custom Start Command in the Deploy section. Head back to the top of the service and click on Variables. Add all the necessary environment variables especially those highlighted already in step 3. Click Deploy. At this point, you should have all three services deployed and connected to the Postgres Database service: Cron Service: This service should run the Laravel Scheduler to manage scheduled tasks. Worker Service: This service should be running and ready to process jobs from the queue. App Service: This service should be running and is the only one that should have a public domain, allowing users to access your application. App service Note: There is a community template available that demonstrates this deployment approach. You can easily deploy this template and then connect it to your own GitHub repository for your application. Logging Laravel, by default, writes logs to a directory on disk. However, on Railway\u2019s ephemeral filesystem, this setup won\u2019t persist logs. To ensure logs and errors appear in Railway\u2019s console or with railway logs, update the LOG_CHANNEL environment variable to errorlog. You can set it via the Railway dashboard or CLI as shown: railway variables --set \"LOG_CHANNEL=errorlog\" Can I Deploy with Laravel Sail? You may be thinking about using Laravel Sail, which is the standard approach for deploying Laravel applications with Docker. At its core, Sail relies on a docker-compose.yml file to manage the environment. However, it's important to note that Railway currently does not support Docker Compose. Next Steps Explore these resources to learn how you can maximize your experience with Railway: Monitoring Deployments Prev RocketNext SymfonyEdit this file on GitHub",
      "title": "Deploy a Laravel App | Railway Docs",
      "url": "https://docs.railway.com/guides/laravel"
    },
    {
      "content": "Railway vs. RenderAt a high level, both Railway and Render can be used to deploy your app. Both platforms share many similarities: You can deploy your app from a Docker image or by importing your app\u2019s source code from GitHub. Multi-service architecture where you can deploy different services under one project (e.g. a frontend, APIs, databases, etc.). Services are deployed to a long-running server. Services can have persistent storage via volumes. Public and private networking are included out-of-the-box. Healthchecks are available to guarantee zero-downtime deployments. Connect your GitHub repository for automatic builds and deployments on code pushes. Create isolated preview environments for every pull request. Support for instant rollbacks. Integrated metrics and logs. Define Infrastructure-as-Code (IaC). Command-line-interface (CLI) to manage resources. Integrated build pipeline with the ability to define pre-deploy command. Support for wildcard domains. Custom domains with fully managed TLS. Schedule tasks with cron jobs. Run arbitrary commands against deployed services (SSH). Shared environment variables across services. That said, there are some differences between the platforms that might make Railway a better fit for you. Scaling strategies Render Render follows a traditional, instance-based model. Each instance has a set of allocated compute resources (memory and CPU). In the scenario where your deployed service needs more resources, you can either scale: Vertically: you will need to manually upgrade to a large instance size to unlock more compute resources. Horizontally: your workload will be distributed across multiple running instances. You can either: Manually specify the machine count. Autoscale by defining a minimum and maximum instance count. The number of running instances will increase/decrease based on a target CPU and/or memory utilization you specify. The main drawback of this setup is that it requires manual developer intervention. Either by: Manually changing instance sizes/running instance count. Manually adjusting thresholds because you can get into situations where your service scales up for spikes but doesn\u2019t scale down quickly enough, leaving you paying for unused resources. Railway Railway automatically manages compute resources for you. Your deployed services can scale up or down based on incoming workload without manual configuration of metrics/thresholds or picking instance sizes. Each plan includes defined CPU and memory limits that apply to your services. You can scale horizontally by deploying multiple replicas of your service. Railway automatically distributes public traffic randomly across replicas within each region. Each replica runs with the full resource limits of your plan. For example, if you're on the Pro plan, each replica gets 32 vCPU and 32 GB RAM. So, deploying 3 replicas gives your service a combined capacity of 96 vCPU and 96 GB RAM. Total resources = number of replicas \u00d7 maximum compute allocation per replica Replicas can be placed in different geographical locations for multi-region deployments. The platform automatically routes public traffic to the nearest region, then randomly distributes requests among the available replicas within that region. No need to define compute usage thresholds. You can also set services to start on a schedule using a crontab expression. This lets you run scripts at specific times and only pay for the time they\u2019re running. Pricing Render Render follows a traditional, instance-based pricing. You select the amount of compute resources you need from a list of instance sizes where each one has a fixed monthly price. While this model gives you predictable pricing, the main drawback is you end up in one of two situations: Under-provisioning: your deployed service doesn\u2019t have enough compute resources which will lead to failed requests. Over-provisioning: your deployed service will have extra unused resources that you\u2019re overpaying for every month. Enabling horizontal autoscaling can help with optimizing costs, but the trade-off will be needing to figure out the right amount of thresholds instead. Additionally, Render runs on AWS and GCP, so the unit economics of the business need to be high to offset the cost of the underlying infrastructure. Those extra costs are then passed down to you as the user, so you end up paying extra for: Unlocking additional features (e.g. horizontal autoscaling and environments are only available on paid plans). Pay extra for resources (e.g., bandwidth, memory, CPU and storage). Pay for seats where each team member you invite adds a fixed monthly fee regardless of your usage. Railway Railway automatically scales your infrastructure up or down based on workload demands, adapting in real time without any manual intervention. This makes it possible to offer a usage-based pricing model that depends on active compute time and the amount of resources it consumes. You only pay for what your deployed services use. Active compute time x compute size (memory and CPU) You don\u2019t need to think about instance sizes or manually configure them. All deployed services scale automatically. If you spin up multiple replicas for a given service, you\u2019ll only be charged for the active compute time for each replica. Railway also has a serverless feature, which helps further reduce costs when enabled. When a service has no outbound requests for over 10 minutes, it is automatically put to sleep. While asleep, the service incurs no compute charges. It wakes up on the next incoming request, ensuring seamless reactivation without manual effort. This is ideal for workloads with sporadic or bursty traffic, so you only pay when your code is running. Finally, Railway\u2019s infrastructure runs on hardware that\u2019s owned and operated in data centers across the globe. This means you\u2019re not going to be overcharged for resources. Dashboard experience Render Render\u2019s dashboard offers a traditional dashboard where you can view all of your project\u2019s resources. Railway Railway\u2019s dashboard offers a real-time collaborative canvas where you can view all of your running services and databases at a glance. You can group the different infrastructure components and visualize how they\u2019re related to one another. Additionally, Railway offers a template directory that makes it easy to self-host open-source projects with just a few clicks. If you publish a template and others deploy it in their projects, you\u2019ll earn a 50% kickback of their usage costs. Check out all templates at railway.com/deploy Summary CategoryRenderRailwayScaling ModelInstance-basedUsage-basedVertical ScalingManual upgrade to larger instance sizes.Scales to plan limits automaticallyHorizontal ScalingManually add/remove instances or autoscaling (based on CPU/memory thresholds); requires tuningManually add replicas, traffic is routed automatically across regions and replicasMulti-region SupportNot supportedBuilt-in support; traffic routed to nearest regionPricing ModelFixed monthly pricing per instance size. Seat-based pricingUsage-based: charged by active compute time \u00d7 compute size. You don't pay for seats. You can invite your whole team for no additional costCost OptimizationRequires tuning to avoid over/under-provisioningInherently optimized. Pay only for used computeInfrastructureRuns on AWS and GCP; feature access and resources cost moreRailway-owned global infrastructure, lower unit costs and features aren't gatedDashboard UXTraditional dashboard to view project resourcesReal-time collaborative canvas with visual infra relationships. Template directory for 1-click deployments Migrate from Render to Railway To get started, create an account on Railway. You can sign up for free and receive $5 in credits to try out the platform. Deploying your app \u201cChoose Deploy from GitHub repo\u201d, connect your GitHub account, and select the repo you would like to deploy. If your project is using any environment variables or secrets: Click on the deployed service. Navigate to the \u201cVariables\u201d tab. Add a new variable by clicking the \u201cNew Variable\u201d button. Alternatively, you can import a .env file by clicking \u201cRaw Editor\u201d and adding all variables at once. To make your project accessible over the internet, you will need to configure a domain: From the project\u2019s canvas, click on the service you would like to configure. Navigate to the \u201cSettings\u201d tab. Go to the \u201cNetworking\u201d section. You can either: Generate a Railway service domain: this will make your app available under a .up.railway.app domain. Add a custom domain: follow the DNS configuration steps. Need help or have questions? If you need help along the way, the Railway Discord and Help Station are great resources to get support from the team and community. Working with a larger workload or have specific requirements? Book a call with the Railway team to explore how we can best support your project.Prev Compare to HerokuNext Compare to FlyEdit this file on GitHub\n\n--- TEXT FROM IMAGES ---\n\nImage: https://res.cloudinary.com/railway/image/upload/v1753470541/docs/comparison-docs/render-instances_swcn49.png\nAlt text: Render instances\nOCR text: Instance Type For hobby projects For professional use For more power and to get the most out of Render, we recommend using one of our paid instance types. All paid instances support: = Zero Downtime = SSH Access = Scaling = One-off jobs = Support for persistent disks Free 512 MB (RAM) $0 / month 01CPU Starter 512 MB (RAM) Standard 2 GB (RAM) $7 /month 0.5 CPU $25 / month 1 CPU Pro 4 GB (RAM) Pro Plus 8 GB (RAM) $85 / month 2 CPU $175 / month 4 CPU Pro Max 16 GB (RAM) Pro Ultra 32 GB (RAM) $225 / month 4 CPU $450 / month 8 CPU Need a custom instance type? We support up to 512 GB RAM and 64 CPUs.\n\nImage: https://res.cloudinary.com/railway/image/upload/v1753470546/docs/comparison-docs/railway-usage-based-pricing_efrrjn.png\nAlt text: Railway usage-based pricing\nOCR text: Railway Resources are dynamically allocated to meet your wo... [truncated]",
      "title": "Railway vs. Render | Railway Docs",
      "url": "https://docs.railway.com/maturity/compare-to-render"
    },
    {
      "content": "Use the Public APIThe Railway public API is built with GraphQL and is the same API that powers the Railway dashboard. Use the Public API to integrate Railway into your CI/CD pipelines and other workflows. Understanding GraphQL If you haven't used GraphQL before, here are a few resources to get started: The official Introduction to GraphQL The GraphQL Basics course by Hasura GraphQL is the better REST to understand how it is different from a REST API Connecting to the Public API To connect to and query the Public API, you will need the endpoint URL and a token for authentication. Endpoint The public API is accessible at the following endpoint: https://backboard.railway.com/graphql/v2 Creating a Token To use the API, you will need an API token. There are three types of tokens you can create. Team Tokens and Account Tokens You can create an API token from the tokens page in your account settings. Team token - Select a team in the Team dropdown to create a token tied to a team. A team token has access to all the team's resources, and cannot be used to access your personal resources on Railway. Feel free to share this token with your teammates. Account token - If you do not select a team, the token will be tied to your Railway account and will have access to all your resources including the teams you are a part of. Do not share this token with anyone else. Note that Teams are a Pro feature. Project Token You can create a project token from the tokens page in your project settings. Project tokens are scoped to a specific environment within a project and can only be used to authenticate requests to that environment. Execute a Test Query Once you have your token, you can pass it within the Authorization header of your request. Using an Account Token You can try the query below in the terminal of your choice. It should return your name and email on Railway: curl --request POST \\ --url https://backboard.railway.com/graphql/v2 \\ --header 'Authorization: Bearer <API_TOKEN_GOES_HERE>' \\ --header 'Content-Type: application/json' \\ --data '{\"query\":\"query { me { name email } }\"}' Note: This query cannot be used with a team or project token because the data returned is scoped to your personal account. Using a Team Token If you have a team token, you can use it to authenticate requests to a specific team. The query below should return the team name and ID: curl --request POST \\ --url https://backboard.railway.com/graphql/v2 \\ --header 'Team-Access-Token: <TEAM_TOKEN_GOES_HERE>' \\ --header 'Content-Type: application/json' \\ --data '{\"query\":\"query { team(id: \\\"<TEAM_ID_GOES_HERE>\\\") { name id } }\"}' Note: This query can also be used with an account token as long as you are a member of the team. Using a Project Token If you have a project token, you can use it to authenticate requests to a specific environment within a project. The query below should return the project and environment IDs: curl --request POST \\ --url https://backboard.railway.com/graphql/v2 \\ --header 'Project-Access-Token: <PROJECT_TOKEN_GOES_HERE>' \\ --header 'Content-Type: application/json' \\ --data '{\"query\":\"query { projectToken { projectId environmentId } }\"}' Viewing the Schema Use popular tools like Postman or Insomnia to connect to the API and query the schema. Simply set up your connection with the endpoint and Authorization token, and fetch the schema. API Collection File We also provide a collection file which can be imported into your preferred API client. Click here to download it. Once imported, you should only need to add your API token to get connected and start executing queries in the collection. GraphiQL Playground Alternatively, you can use our GraphiQL playground to view the schema and test your queries. Make sure to set an Authorization header with an auth token. Click the \"Headers\" tab at the bottom of the GraphiQL page and enter this json, using your own token: {\"Authorization\": \"Bearer <API_TOKEN_GOES_HERE>\"} Tips and Tricks Resource IDs While building your queries, if you quickly need to copy resource IDs, you can hit Cmd/Ctrl + K within your project and copy the project/service/environment ID. The Network Tab If you're unsure about what query/mutation to use for what you are trying to achieve, you can always do the action in the dashboard and look for the request in the network tab. As we use the same API internally, you can simply grab the name and then look for specific query in the introspected schema. External Resources The awesome-graphql repository is a great resource for all things GraphQL with implementations available across a variety of languages. The GraphQL Discord is the official Discord channel for graphql.org with a lot of active members and specific help channels. Examples To help you get started, we have provided some example queries in the guides within this section - Manage Projects Manage Services Manage Deployments Manage Variables Support If you run into problems using the API or have any suggestions, feel free to join our Discord server where you can interact with the engineers working on the API directly. Rate Limits Rate limits are enforced on the Public API. For details on the limits visit the Public API reference page.Prev DeployNext Manage ProjectsEdit this file on GitHub",
      "title": "Use the Public API | Railway Docs",
      "url": "https://docs.railway.com/guides/public-api"
    },
    {
      "content": "Migrate from HerokuMigrating your app from Heroku to Railway is very simple. We even support Procfiles out of the box. (Only a single process is supported for now). All you need to do is create a project in Railway, push your code, and migrate your envionment variables. This guide will step you through the process of migrating a simple web service, using the Railway CLI. Working Directory In your terminal, ensure your current working directory is the same directory where your service code is located. This is important so that as you complete the following steps, the Railway CLI is properly linked. 1. Login to Railway From the CLI Ensure your CLI is authenticated to your Railway account: railway login This command will prompt to open a browser to complete authentication. Once authenticated, commands executed by the Railway CLI, will be performed in the context of your Railway account. 2. Create a New Project Now, let's create a new project: railway init This command will prompt you to define a name for your service. 3. Deploy the Service Once your project is created, you can push your code into the project and assign a domain. Push the Code Push the code into a service in Railway: railway up -d At this point, the service is being deployed, but let's give it a domain. Assign a Domain The service we are migrating is a web service that should be available over the Internet, so let's assign a domain: railway domain Now the service will be available over the Internet via the provided domain. 4. Migrate the Environment Variables Finally, we will import the environment variables from Heroku into Railway. Open the Project in Railway Let's pop over to our new project in the Railway canvas.: railway open This will open the project in your browser. Add Heroku Variables to the Service From the project canvas, import the Heroku variables into the service: click on the service click Variables tab open the command palette using CMD + K or Ctrl + K. search for Import variables from Heroku confirm the Heroku service and hit Enter Your Heroku variables will be imported into the service, and it will automatically redeploy. Note: The first time you import variables from Heroku, you will be prompted to Allow Railway to connect to your Heroku account. Conclusion Following this guide, we have successfully migrated a simple web service from Heroku to Railway, including importing variables from Heroku into Railway. We have completed the migration by pushing our code directly from our local machine into a service in Railway. Once you are comfortable with Railway, you may want to integrate deployments into your development workflow. For more advanced operations, like migrating your databases from Heroku to Railway, the process will be a bit more involved, but we are happy to help work out a solution! Need Help? If you run into any issues, or would like help with your migrations, we would be more than happy to answer your questions on our Discord or over email at [email\u00a0protected].Prev Migrate from DigitalOceanNext The Conductor ProgramEdit this file on GitHub",
      "title": "Migrate from Heroku | Railway Docs",
      "url": "https://docs.railway.com/migration/migrate-from-heroku"
    },
    {
      "content": "Migrate from DigitalOcean to RailwayThis guide demonstrates how to migrate your WordPress site from DigitalOcean to Railway's modern cloud platform. Railway provides a streamlined deployment experience with powerful infrastructure features. Railway offers: Modern Infrastructure: High-performance cloud platform Quick Setup: WordPress-ready deployment template Database Support: MariaDB database capabilities Integrated SSL: Automatic SSL certificate management Scalable Infrastructure: Easily handle traffic spikes and growth Collaborative Features: Team management, deployment protection, and role-based access Priority Support: Dedicated support for Railway users Migration Steps Let's walk through migrating a WordPress site from DigitalOcean to Railway. This process involves backing up your existing installation, deploying WordPress on Railway and then restoring from your backup. 1. Backup your WordPress site Ensure you have a backup of your existing site. Use a WordPress backup plugin of your choice to export your site data. Make sure this backup includes, All WordPress files, All WordPress database tables, All WordPress uploads. Document your current configuration Note any custom domain settings Keep track of your username and password for wp-admin. 2. Deploy WordPress Open the WordPress Template page Click \"Deploy Now\" to Deploy the WordPress template. Since this template doesn\u2019t require any configuration, Click \"Deploy\" and wait for the deployment to complete. The template will automatically configure - A MariaDB database Initial WordPress setup Required environment variables A temporary service domain 3. Restore your site content After the template deployment completes - Access your WordPress installation via the temporary service domain. Configure your WordPress settings Install your preferred backup plugin Restore your site content from your backup 4. Configure Domain Settings To set up your custom domain: Open your service's Settings in Railway Navigate to the \"Networking\" section Add your custom domain Update your DNS records according to the instructions given. Note: You will need to redeploy your service for WordPress to pick up the new domain. 5. Verify Migration Before finalizing your migration - Test all WordPress functionality Verify all pages and posts are displaying correctly Check media files are properly loaded Test user authentication Verify contact forms and other interactive elements 6. Performance Optimization Consider these optimization options for your WordPress deployment: Configure caching by placing Cloudflare or a similar CDN in front of your site. Optimize database performance by setting up a caching plugin. Set up appropriate scaling configurations. Implement CDN if needed That's all you need to migrate your WordPress site from DigitalOcean to Railway! Need assistance? The Central Station is there to help you with any questions during your migration process.Prev Migrate from VercelNext Migrate from HerokuEdit this file on GitHub",
      "title": "Migrate from DigitalOcean to Railway | Railway Docs",
      "url": "https://docs.railway.com/migration/migrate-from-digitalocean"
    },
    {
      "content": "Use CasesRailway is suited for a variety of use-cases. This page will walk-through what the platform is perfect for today and our recommendations for apps of all sizes. As mentioned in our philosophy document. Railway will make a best effort to provide all the information a developer needs to make the best choice for their workload. Is Railway Production Ready? Many of our customers use Railway to reliably deploy their applications to customers at scale. With that said, Production standards are going to be different depending on what your users expect. We have companies that use Railway in a variety of different verticals such as: Enterprise SaaS Consumer Social Education E-Commerce Crypto ML/AI Agencies Companies on Railway range from hobby projects, to extremely fast growing startups, to publicly traded companies. Railway has been incrementally adopted from using the platform as a developer's scratchpad before writing Terraform to hand off to an Ops. team or being implemented end to end. Railway's been in operation for now for more than three years and we have served billions of requests, with 100s of millions of deploys serving millions of end-users simultaneously. Railway Scale All of these verticals deploy workloads that may require high bandwidth operations or intensive compute. However, service scale on the platform is not unbounded. As a foundational infrastructure company, we understand that customers may outpace our pace of improvement for the platform. Even though 32 vCPU and 32 GB of memory sounds like a lot (with up to 20 replicas) on the Pro plan, when faced with hyper-growth: throwing more resources at the issue might be your best bet until long term optimizations can be made by your team. Railway will gladly bump up your service limits within your tier of service to meet your needs. Even so, we will be frank and honest if you may need to seek elsewhere to augment your workloads with extra compute. If your compute needs outpace our Pro offering, consider our Enterprise plans where we offer even greater limits and capacity planning, email us to learn more, or click here to schedule some time to chat. Databases We have customers using our databases for their production environment with no issue. Railway's plugins are optimized for a batteries included development experience. They are good for applications that are prioritizing velocity and iteration speed over scale. Our databases are provided with no SLAs, are not highly available, and scale only to the limits of your plan. We don't think they are suitable for anything mission-critical, like if you wanted to start a bank. We advise developers to: Configure backups Run-book and restore their backups Configure secondaries to connect to in-case of a disaster situation Included in our planned near-term work for databases on Railway are additional database metrics, and SSH access into the running database. As mentioned before: we don't believe in vendor lock-in here at Railway, if your needs outpace us, consider other vendors like PlanetScale (for MySQL) or Cockroach (for Postgres). Metrics Railway provides up to 7 days worth of data on service information such as: CPU Memory Disk Usage Network We also overlay commit and deployment behavior to correlate issues with application health to deployments. This is on top of the service logs that are continually delivered to users viewing a particular deployment of a service. For service logs, we store logs for up to 90 days for Pro plan workspaces. Included in our planned near-term work for logging and observability on Railway are improvements to structured logging, and OpenTelemetry compatible endpoints. It is common for teams who wish to have additional observability to use an additional monitoring tool that maintains a longer time horizon of data such as New Relic, Sentry, or Datadog. Within projects, deploying a Datadog Agent is as easy as deploying the template and providing your Datadog API Keys. Networking Railway doesn't have a hard bandwidth limit to the broader internet. We may throttle your outbound bandwidth and reach out to you when it exceeds 100GB/month to ensure the legitimacy of your workloads. If you need to control where your traffic is allowed to come from such as setting up firewall rules, we recommend setting up Cloudflare or an external load balancer/L7 application firewall to handle it. Private networking bandwidth is un-metered. We intend to provide advanced traffic-shaping controls within Railway in the future. Service Level Objectives Railway does meet SLOs for companies who have greater need for incident, support, and business planning responsiveness. We provide this via Business Class, offered as an add-on to Pro plans and included in all Enterprise plans. More info. Will Railway exist in 10 years? A common question we get in conversations with (rightly) skeptical developers is the above question. Most documentation pages don't address the meta question of a company's existence but how we run our business affects yours. The short and simple answer is: Yes. Railway aims to exist for a very long time. Railway has presence on existing public clouds, while also building out presence on co-location providers. As a company, we have been structured sustainably with a first principles approach to every expense while growing sustainably. Unsupported Use-Cases Unfortunately, our platform isn't yet well-equipped to handle the following verticals that require extensive Gov't certification or GPU compute: Government Traditional Banking Machine Learning Compute General Recommendations A document like this can only go so far. We have a standing invitation for any team who needs an extended scale use-case to reach out to us directly by e-mailing [email\u00a0protected], or via our Discord server. You can also schedule some time with us directly by clicking here. We would be happy to answer any additional questions you may have.Prev PhilosophyNext ComplianceEdit this file on GitHub",
      "title": "Use Cases | Railway Docs",
      "url": "https://docs.railway.com/maturity/use-cases"
    },
    {
      "content": "FoundationsWelcome! Let's get started building in Railway! To start, you should be familiar with the core components and features of the platform. Therefore, the goal of this section is to guide you through the steps of laying a solid foundation on which to iterate. Core Components ProjectsA Project is like an application stack, or a system of related components. Everything needed by the components in the system are encapsulated in a Project, including environments and variables.ServicesServices are components that make up the Project - frontend web servers, backend APIs, message queues, databases, etc. Services can be configured with variables, start and run commands, restart policies, volume mounts, etc.VariablesVariable management is an essential part of development operations. Variables can be scoped to both Services and Environments in Railway.EnvironmentsEnvironments exist within a Project and are useful for maintaining separation between Production and Development environments.CLIThe CLI is handy for local development, used for things like running services locally using variables stored in Railway, deploying local code repositories, etc. The next pages will go through how to create and manage your Projects, Services, Variables, and Environments. They will also explain how to use Volumes to persist your data and how to install and use the CLI. If you prefer a crash course, check out our Quickstart guide!Prev Advanced ConceptsNext ProjectsEdit this file on GitHub",
      "title": "Foundations | Railway Docs",
      "url": "https://docs.railway.com/guides/foundations"
    },
    {
      "content": "Migrate from Fly to RailwayThis guide walks you through the steps needed to seamlessly migrate your app and data from Fly.io to Railway. This process is straightforward and typically takes an average of 5 - 20 minutes, depending on the size of your database and app complexity. TL;DR: Quick Migration Steps Set up new app on Railway Export data from Fly.io and Import into Railway DB Deploy app (including auto-migration of app config & variables) We provide everything Fly.io offers\u2014and more! Check out our comparison guide to see the differences and make an informed choice. Why take our word for it? Experience the Railway advantage yourself\u2014give it a spin today! Migration Steps In this guide, we will migrate a Go (Gin) app with a Postgres database from Fly.io to Railway. While we are using this app as an example, the process applies to any app, making it easy to transition your projects smoothly. Here\u2019s the link to the app. 1. Set Up a Railway Project Navigate to Railway's Project Creation Page. Select the Deploy from GitHub Repo option and connect your repository. If your Railway account isn\u2019t linked to GitHub yet, you\u2019ll be prompted to do so. 2. Deploy the App Railway auto-imports all the build configurations, deploy commands, environment variables from your Fly.io app repo\u2014no manual setup needed. If the environment variables are missing, you can easily add them manually by following these steps: Adding Environment Variables on Railway: Navigate to the Variables section of your service. Switch to the Raw Editor and paste the copied environment variables. Deploy the changes to apply the configuration. Railway will deploy the Gin app as a service, as shown in the image above. You can monitor the service building and deploying in the Project Canvas. Serverless (App Sleep) activated: In this Fly.io app, the HTTP service is configured with auto_stop_machines='stop' and auto_start_machines=true, enabling automatic stopping and restarting of machines. On Railway import, we automatically enable this setting to effortlessly optimize resource usage. 3. Database Migration Railway supports a variety of databases, including PostgreSQL, MongoDB, MySQL, and Redis, allowing you to deploy the one that best fits your application needs. We also support many more via our templates marketplace. If you're migrating data to Railway from Fly, you can follow these steps: Provision a new database by right clicking on the dashboard canvas and selecting Postgres. Export your data from Flyio Use flyctl to connect to your Flyio Postgres instance fly postgres connect -a <postgres-app-name> Use pg_dump to export your database pg_dump -Fc --no-acl --no-owner -h localhost -p 5432 -U <your-db-username> -d <your-db-name> -f flyio_db_backup.dump Use pg_restore to connect to your Railway database and restore the data from the dump. pg_restore -U <username> -h <host> -p <port> -W -F t -d <db_name> <dump_file_name> For detailed instructions, check out this comprehensive tutorial on migrating PostgreSQL data between services. Once the migration is complete, update the DATABASE_URL environment variable in your Railway app to point to the new PostgreSQL database and redeploy. 4. Replicas & Multi-region deployments In this Fly.io app, the setting min_machines_running=2 ensures that at least two instances of the service remain active. On Railway import, we automatically translate this configuration to ensure that two service instances are running without any extra setup. If your app needs to use multi-region deployments, you can leverage Railway\u2019s multi-region replicas. Enable this in the Settings section of your Railway service to keep your app close to users worldwide. Note: Multi-region replicas is currently available to Pro users. And that\u2019s it. That\u2019s all you need to migrate your app from Flyio to Railway.Prev Migrate from RenderNext Migrate from VercelEdit this file on GitHub\n\n--- TEXT FROM IMAGES ---\n\nImage: https://res.cloudinary.com/railway/image/upload/v1737143344/railwaynewproject_d4jv8c.png\nAlt text: Railway new project\nOCR text: | New Project wp New Project Deploy your app to production effortlessly What can we help with? \u00a9) Deploy from GitHub repo S Dep ~s @ Dep Ss Dep Dep Dep oy a template oy PostgreSQL oy Redis oy MongoDB oy MySQL Empty project Admin Dashboard &\n\nImage: https://res.cloudinary.com/railway/image/upload/v1737143351/environmentvariables_q0xmyh.png\nAlt text: Variables imported automatically from fly.toml into Railway service\nOCR text: \u00a9 gin x Deployments Variables Metrics Settings Admin 2 Service Variables Y Shared Variable {} Raw Editor + New Variable > 8 Railway Provided Variables available \u00a9 gin {} LOG_LEVEL spo K : gin-production-5b03.up. rail... (} \u00a73_BUCKET eee : GS 8 minutes ago via GitHub LS 2replicas\n\nImage: https://res.cloudinary.com/railway/image/upload/v1737143360/appsleep_cszmgf.png\nAlt text: App sleep activated to optimize resource usage and spend\nOCR text: \u00a9 gin x Deployments Variables Metrics Settings Admin 2 Service Variables Y Shared Variable {} Raw Editor + New Variable > 8 Railway Provided Variables available \u00a9 gin {} LOG_LEVEL sp K : gin-production-5b03.up. rail... (} $3. BUCKET starsat : G Sleeping since 13 seconds Tere) LS 2replicas\n\nImage: https://res.cloudinary.com/railway/image/upload/v1737143335/replicas_zwtuwr.png\nAlt text: Replicas\nOCR text: Q sin gin-production-5b03.up. rail... G 17 minutes ago via GitHub LS 2replicas \u00a9) gin Deployments Variables Metrics Settings Admin Filter Settings... \u00a9 Deploy Pre-deploy Command Run a command in your image before your application deploys. Docs \u201d go version Custom Start Command Command that will be run to start new deployments. Docs 7 + Start Command Regions Configure how many instances of this service are deployed in each region. = US West (Oregon, USA) v 2 Instances Multi-region replicas are only available on the Pro plan. Learn More a Resource Limits Max amount of vCPU and Memory to allocate to each replica for this service. Source Networking Build Deploy Config-as-code Feature-flags Danger\n",
      "title": "Migrate from Fly to Railway | Railway Docs",
      "url": "https://docs.railway.com/migration/migrate-from-fly"
    },
    {
      "content": "Migrate from Vercel to RailwayThis guide demonstrates how to transition your application from Vercel to Railway's developer-centric platform. Whether you're running a simple static site or a complex full-stack application, Railway streamlines your deployment workflow. With features like instant rollbacks, integrated observability, and seamless environment management, Railway empowers developers to focus on building great applications rather than managing infrastructure. Railway offers - Next.js Optimization: Built-in support for all Next.js features including ISR, SSR, and API routes Zero Config Deployments: Automatic framework detection and build optimization Enhanced Development Flow: Local development with production parity Collaborative Features: Team management, deployment protection, and role-based access Priority Support: Dedicated support for Railway users Migration Steps Let's walk through migrating a Next.js application to Railway. For this guide, we'll use a sample e-commerce app that showcases common Next.js features and configurations. Deploying Your Application To get started deploying our NextJS app, we will first make a new project. Open up the dashboard \u2192 Click New Project. Choose the GitHub repo option. Railway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it. Search for your GitHub project and click on it. Choose either Deploy Now or Add variables. Deploy Now will immediately start to build and deploy your selected repo. Add Variables will bring you to your service and ask you to add variables, when done you will need to click the Deploy button at the top of your canvas to initiate the first deployment. For brevity we will choose Deploy Now. When you click Deploy Now, Railway will create a new project for you and kick off an initial deploy after the project is created. Once the project is created you will land on your Project Canvas. From here Railway will automatically - Detect your Next.js configuration Configure the appropriate Node.js version Build your application Run your application Environment Configuration Next.js applications often rely on environment variables for API keys, database connections, and feature flags. Here's how to transfer them - From Vercel - Visit your Vercel project settings Navigate to the Environment Variables tab Export your variables (you can copy them directly) To Railway - Select your service in the Project Canvas Open the Variables tab Use the Raw Editor for bulk variable import Click Deploy to apply changes Domain Configuration Railway makes it simple to set up custom domains or use our provided domains - Open your service's Settings Navigate to the Public Networking section Choose between: Generating a Railway service domain Adding your custom domain Follow the DNS configuration steps if using a custom domain Deployment Verification Before finalizing your migration: Check your application's core functionality Verify environment variables are properly set Test dynamic routes and API endpoints Confirm image optimization is working Monitor build and runtime logs Railway's integrated observability helps you catch any issues early in the migration process. Local Development Railway makes local development seamless with your production environment: Install the Railway CLI: npm i -g @railway/cli Run railway link to connect to your project Use railway run to start your app locally with production variables This ensures development/production parity and helps catch issues before they reach production. That's all it takes to move your Next.js application to Railway! Need help? Our team and community are always ready to assist. Need more information on how we compare to Vercel? Check out our comparison page.Prev Migrate from FlyNext Migrate from DigitalOceanEdit this file on GitHub",
      "title": "Migrate from Vercel to Railway | Railway Docs",
      "url": "https://docs.railway.com/migration/migrate-from-vercel"
    },
    {
      "content": "Public API ReferenceThe Railway public API is built with GraphQL and is the same API that powers the Railway dashboard. Endpoint The public API is accessible at the following endpoint: https://backboard.railway.com/graphql/v2 Authentication To use the API, you will need an API token. There are three types of tokens you can create. Team Token and Personal Token You can create an API token by visiting the tokens page in your account settings. Team tokens are tied to a team and will have access to all the team's resources. This token cannot be used to access your personal resources on Railway so feel free to share it with your teammates. Non-team tokens will be tied to your Railway account and will have access to all your resources. Do not share this token with anyone else. curl --request POST \\ --url https://backboard.railway.com/graphql/v2 \\ --header 'Authorization: Bearer <API_TOKEN_GOES_HERE>' \\ --header 'Content-Type: application/json' \\ --data '{\"query\":\"query { me { name email } }\"}' Project Token You can create a project token by visiting the tokens page in your project settings. Project tokens are scoped to a specific environment within a project and can only be used to authenticate requests to that environment. curl --request POST \\ --url https://backboard.railway.com/graphql/v2 \\ --header 'Project-Access-Token: <PROJECT_TOKEN_GOES_HERE>' \\ --header 'Content-Type: application/json' \\ --data '{\"query\":\"query { projectToken { projectId environmentId } }\"}' Schema The Railway API supports introspection meaning you can use popular tools like Postman or Insomnia to query the schema. Simply set up your connection with the endpoint and Authorization token, and fetch the schema. API Collection File We provide a collection file which can be imported into your preferred API client. Once imported, you should only need to add your API token to get connected and start executing queries in the collection. Click here to download it. GraphiQL Playground Use our GraphiQL playground to view the schema and test your queries. Make sure to set an Authorization header with an auth token. Click the \"Headers\" tab at the bottom of the GraphiQL page and enter this json, using your own token: {\"Authorization\": \"Bearer <API_TOKEN_GOES_HERE>\"} Rate Limits In order to protect the Railway API from spam and misusage, we have established some basic rate limits. The current limits to the API are: 1000 requests per hour Requests per second: 10 RPS for Hobby users; 50 RPS for Pro users; custom for Enterprise To help you keep track of your usage, Railway sends a few headers with the response on each request. HeaderDescriptionX-RateLimit-LimitThe maximum number of API requests allowed per day.X-RateLimit-RemainingThe number of API requests your token can make in the current window.X-RateLimit-ResetThe time at which the current window ends and your remaining requests reset.Retry-AfterThe amount of time after which you can make another request. This header is only sent once you've used up all your requests in the current window. Support For more information on how to use the Public API and for examples of queries, view the Public API guide. If you run into problems using the API or have any suggestions, feel free to join our Discord server where you can interact with the engineers working on the API directly.Prev CLI APINext TemplatesEdit this file on GitHub",
      "title": "Public API Reference | Railway Docs",
      "url": "https://docs.railway.com/reference/public-api"
    },
    {
      "content": "Deploy a Phoenix AppPhoenix is popular Elixir framework designed for building scalable, maintainable, and high-performance web applications. It is known for its ability to handle real-time features efficiently, like WebSockets, while leveraging Elixir's concurrency model, which is built on the Erlang Virtual Machine (BEAM). Create a Phoenix App Note: If you already have a Phoenix app locally or on GitHub, you can skip this step and go straight to the Deploy Phoenix App on Railway. To create a new Phoenix app, ensure that you have Elixir and Hex package manager installed on your machine. Once everything is set up, run the following command in your terminal to install the Phoenix application generator: mix archive.install hex phx_new Next, run the following command: mix phx.new helloworld Select Y to install all dependencies. This command will create a new Phoenix app named helloworld with some optional dependencies such as: Ecto for communicating with a database such as PostgreSQL, MySQL etc Phoenix live view for building realtime & interactive web apps. Phoenix HTML and Tailwind CSS for HTML apps. Configure Database Next, navigate into the helloworld directory using the cd command. Open up the config/dev.exs file. You'll notice that a new Phoenix app is already set up with PostgreSQL settings. It assumes the database has a postgres user with the right permissions and a default password of postgres. Update the username and password to match your local PostgreSQL account credentials. Note: If you prefer using a different database, like MySQL, you can easily switch the database adapter in the mix.exs file. Simply remove the Postgrex dependency and add MyXQL instead. For detailed instructions, check out this guide on using other databases in Phoenix. The default database name is set to helloworld_dev, but feel free to change it to whatever you'd prefer. Next, create the database for our app by running the following command: mix ecto.create A database will be created for our app. Run the Phoenix App locally Start the app by running the following command: mix phx.server By default, Phoenix accepts requests on port 4000. Open your browser and go to http://localhost:4000 to see your app. Now that your app is running locally, let\u2019s move on to deploying it to Railway! Prepare our Phoenix App for deployment Go ahead and create a nixpacks.toml file in the root directory of our Phoenix app. The nixpacks.toml file is a configuration file used by Nixpacks, a build system developed and used by Railway, to set up and deploy applications. In this file, you can specify the instructions for various build and deployment phases, along with environment variables and package dependencies. Add the following content to the file: # nixpacks.toml [variables] MIX_ENV = 'prod' [phases.setup] nixPkgs = ['...', 'erlang'] [phases.install] cmds = [ 'mix local.hex --force', 'mix local.rebar --force', 'mix deps.get --only prod' ] [phases.build] cmds = [ 'mix compile', 'mix assets.deploy' ] [start] cmd = \"mix ecto.setup && mix phx.server\" [variables] This section contains the list of env variables you want to set for the app. MIX_ENV = 'prod': It sets the Elixir environment to prod. [phases.setup]: This defines a list of Nix packages to be installed during the setup phase. The placeholder '...' should be replaced with any additional packages needed for your application. The inclusion of erlang indicates that the Erlang runtime is required for the Elixir application. [phases.install]: This section contains a list of commands to run during the installation phase. mix local.hex --force: Installs the Hex package manager for Elixir, which is necessary for managing dependencies. mix local.rebar --force: Installs Rebar, a build tool for Erlang. mix deps.get --only prod: Fetches only the production dependencies defined in the mix.exs file. [phases.build]: This section contains commands to run during the build phase. mix compile: Compiles the Elixir application. mix assets.deploy: This is a command to handle the deployment of static assets (e.g., JavaScript, CSS) for our app. [start]: This section contains commands to run when starting the application. mix ecto.setup: This command is used to set up the database by running migrations and seeding it. It prepares the database for the application to connect. mix phx.server: This starts the Phoenix server, allowing the application to begin accepting requests. Now, we are ready to deploy! Deploy Phoenix App to Railway Railway offers multiple ways to deploy your Phoenix app, depending on your setup and preference. Choose any of the following methods: One-click deploy from a template. Using the CLI. From a GitHub repository. One-Click Deploy from a Template If you\u2019re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Phoenix app along with a Postgres database. Click the button below to begin: After deploying, we recommend that you eject from the template to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project. Deploy from the CLI To deploy the Phoenix app using the Railway CLI, please follow the steps: Install the Railway CLI: Install the CLI and authenticate it using your Railway account. Initialize a Railway Project: Run the command below in your Phoenix app directory. railway init Follow the prompts to name your project. After the project is created, click the provided link to view it in your browser. Deploy the Application: Use the command below to deploy your app: railway up This command will scan, compress and upload your app's files to Railway. You\u2019ll see real-time deployment logs in your terminal. Note: You might encounter an error\u2013\u2013warning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8..... Don\u2019t worry, we\u2019ll address this in the next step. Add a Database Service: Run railway add. Select PostgreSQL by pressing space and hit Enter to add it to your project. A database service will be added to your Railway project. Configure Environment Variables: Go to your app service Variables section and add the following: SECRET_KEY_BASE : Set the value to the your app's secret key. You can run mix phx.gen.secret locally to generate one. LANGand LC_CTYPE: Set both values to en_US.UTF-8. This sets your app's locale and gets rid of the native name encoding of latin1 warning. DATABASE_URL: Set the value to ${{Postgres.DATABASE_URL}} (this references the URL of your new Postgres database). Learn more about referencing service variables. ECTO_IPV6: Set the value to true to enable your Phoenix app to connect to the database through the IPv6 private network. Use the Raw Editor to add any other required environment variables in one go. Redeploy the Service: Click Deploy on the Railway Project Canvas to apply your changes. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. Deploy from a GitHub Repo To deploy the Phoenix app to Railway, start by pushing the app to a GitHub repo. Once that\u2019s set up, follow the steps below to complete the deployment process. Create a New Project on Railway: Go to Railway to create a new project. Deploy from GitHub: Select Deploy from GitHub repo and choose your repository. If your Railway account isn\u2019t linked to GitHub yet, you\u2019ll be prompted to do so. Add Environment Variables and Provision a Database Service: Click Add Variables, but hold off on adding anything just yet. First, proceed with the next step. Right-click on the Railway project canvas or click the Create button, then select Database and choose Add PostgreSQL. This will create and deploy a new PostgreSQL database for your project. Once the database is deployed, you can return to adding the necessary environment variables: SECRET_KEY_BASE : Set the value to the your app's secret key. You can run mix phx.gen.secret locally to generate one. LANGand LC_CTYPE: Set both values to en_US.UTF-8 to ensure proper locale settings and avoid the native name encoding of latin1 warning. DATABASE_URL: Set the value to ${{Postgres.DATABASE_URL}} (this references the URL of your new Postgres database). Learn more about referencing service variables. ECTO_IPV6: Set the value to true to enable your Phoenix app to connect to the database through the IPv6 private network. Deploy the App Service: Click Deploy on the Railway project canvas to apply your changes. Verify the Deployment: Once the deployment completes, go to View logs to check if the server is running successfully. Note: During the deployment process, Railway will automatically detect that it\u2019s an Elixir app. Set Up a Public URL: Navigate to the Networking section under the Settings tab of your new service. Click Generate Domain to create a public URL for your app. This guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Phoenix apps effortlessly! Want to Deploy Livebook? Livebook, an interactive notebook tool built specifically for Elixir, provides a powerful and intuitive environment for exploring data, running code, and documenting insights, all in one place. It\u2019s perfect for experimenting with Elixir code, prototyping, and sharing live documentation. Click the button below to deploy an instance of Livebook quickly. Next Steps Explore these resources to learn how you can maximize your experience with Railway: Deploy Phoenix with Distillery Monitoring Deployments Prev SolidNext Phoenix DistilleryEdit this file on GitHub",
      "title": "Deploy a Phoenix App | Railway Docs",
      "url": "https://docs.railway.com/guides/phoenix"
    },
    {
      "content": "The BasicsThis document outlines the core concepts of Railway, providing foundational knowledge of the basic building blocks you'll work with in the platform. In a Nutshell Dashboard - Main entrypoint for all projects under your account. Project - A collection of services under the same network. Project Settings - Contains all project-level settings. Service - A target for a deployment source (e.g. Web Application). Service Variables - A collection of configurations and secrets. Backups - A collection of backups for a service. Service Metrics - Rundown of metrics for a service. Service Settings - Contains all service-level settings. Deployment - Built and deliverable unit of a service. Volumes - Persistent storage solution for services. Volume Metrics - Rundown of metrics for volumes (e.g. disk usage over time). Volume Settings - Contains all volume-level settings. Dashboard / Projects Your main entrypoint to Railway where all your projects are shown in the order they where last opened. Projects contain your services and environments. Project / Project Canvas A project represents a capsule for composing infrastructure in Railway. You can think of a project as an application stack, a service group, or even a collection of service groups. Services within a project are automatically joined to a private network scoped to that project. Project Settings This page contains all the project level settings. Some of the most commonly used project settings are - Transfer Project - Transfer your project between workspaces. Environments - Manage various settings regarding environments. Members - Add or remove members to collaborate on your project. Danger - Remove individual services or delete the entire project. Services A Railway service is a deployment target for your deployment source. Deployment sources can be code repositories or Docker Images. Once you create a service and choose a source, Railway will analyze the source, build a Docker image (if the source is a code repository), and deploy it to the service. Out of the box, your service is deployed with a set of default configurations which can be overridden as needed. Service Variables Service Variables provide a powerful way to manage configuration and secrets across services in Railway. You can configure variables scoped to services. These variables are specific to each service and are not shared across the project by default. If you want to access variables from this service in another service within the same project, you need to utilize a Reference Variable. Backups If your service has a volume attached, this is where you can manage backups. Backups are incremental and Copy-on-Write, we only charge for the data exclusive to them, that aren't from other snapshots or the volume itself. From here you can perform the following actions - Create a backup - Manually create a backup of the volume with a press of a button. Delete a backup - Remove a backup from the list via the backup's 3-dot menu. Lock a backup - Prevent a backup from being deleted via the backup's 3-dot menu. Restore a backup - Click the Restore button on the backup. Modify the backup schedule - Click the Edit schedule button on the header to make changes to the schedule. Service Metrics Service Metrics provide an essential overview of CPU, memory, and network usage for a given service. Service Settings This tab contains all the service level settings. Some of the most commonly used service settings are - Source - Here you can configure the deployment source, which can be either a GitHub repository with a specific branch or an image with optional credentials. Networking - Generate a Railway-provided domain or add your own custom one. Custom Build Command - Here you can configure a custom build command if you need to overwrite the default, only applicable with Nixpacks based builds. Custom Start Command - Here, you can configure a custom start command if you need to overwrite the default. Deployments Deployments involve building and delivering your Service. Volumes Volumes are a feature that allows services on Railway to maintain persistent data. Volume Metrics Volume Metrics show the amount of data stored in the volume and its maximum capacity. Volume Settings This tab contains all the volume centric settings. Some of the most commonly used volume settings are - Mount path - The absolute path where the volume will be mounted within the deployed service. Volume Size - Displays the current volume capacity and offers the option to expand it if your plan permits. Wipe Volume - This action wipes all data in the volume and then redeploys the connected service. What Next? If you've read enough for now and are ready to get started, we suggest checking out either of these two resources next - Quick Start guide to deploy a To Do app from a template. Guides section to dive into how things work. If you want to go deeper, click the Next button below to head to the next section - Advanced Concepts.Prev About RailwayNext Best PracticesEdit this file on GitHub",
      "title": "The Basics | Railway Docs",
      "url": "https://docs.railway.com/overview/the-basics"
    }
  ],
  "api_credentials": {
    "api_documents": [],
    "cohere_knowledge": [
      {
        "content": "Deploy FastAPI applications to Railway using uvicorn with proper host and port configuration. Use requirements.txt for dependencies and set start command to uvicorn main:app --host 0.0.0.0 --port $PORT",
        "title": "FastAPI Railway Deployment"
      },
      {
        "content": "\n                This API was deprecated in 2022 but documentation remains for historical reference.\n                The endpoints described here are no longer functional and should not be used in\n                new applications. Please refer to the new API documentation for current endpoints.\n                ",
        "title": "Legacy API Documentation (CohereKnowledge)"
      }
    ]
  }
}